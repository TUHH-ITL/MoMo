# struct syntax
nodes:
  node1:
    id: 1
    name: front_left_wheel_joint # ['front_left_wheel_joint', 'middle_left_wheel_joint' 'rear_left_wheel_joint']
    eds_pkg: maxon_epos4_ros_canopen # optionals package  name for relative path
    eds_file: "config/motor1.dcf" # path to EDS/DCF file
  node2:
    id: 2
    name: front_right_wheel_joint
    eds_pkg: maxon_epos4_ros_canopen # optionals package  name for relative path
    eds_file: "config/motor2.dcf" # path to EDS/DCF file
  node3:
    id: 3
    name: back_left_wheel_joint
    eds_pkg: maxon_epos4_ros_canopen # optionals package  name for relative path
    eds_file: "config/motor3.dcf" # path to EDS/DCF file
  node4:
    id: 4
    name: back_right_wheel_joint
    eds_pkg: maxon_epos4_ros_canopen # optionals package  name for relative path
    eds_file: "config/motor4.dcf" # path to EDS/DCF file
    
defaults: # optional, all defaults can be overwritten per node
  #  eds_pkg: my_config_package # optional package  name for relative path
  #  eds_file: "my_config.dcf" # path to EDS/DCF file
  #  dcf_overlay: # "ObjectID": "ParameterValue" (both as strings)
  #    "6098": "0" # No homing operation required
  #    "1016sub1" : "0x7F0064" # heartbeat timeout of 100 ms for master at 127
  #    "1017": "100" # heartbeat producer

  # canopen_chain_node settings ..
  motor_allocator: canopen::Motor402::Allocator # select allocator for motor layer
  #   motor_layer: settings passed to motor layer (plugin-specific)
  switching_state: 9 # (Operation_Enable), state for mode switching. Drive mode of operation from canopen_402 wiki
  #pos_to_device: "rint(rad2deg(pos)*8192*21/360)" # rad -> inc, for a MILE 800 CPT encoder and a 26:1 gearbox, 3200 = 4*800
  pos_to_device: "rint(rad2deg(pos)*8192*21/360)" # rad -> inc, for a MILE 800 CPT encoder and a 26:1 gearbox, 3200 = 4*800
  pos_from_device: "deg2rad(obj6064*360/8192/21)" # actual position [inc] -> rad

  #pos_from_device: "(obj6064*2*pi)/(6016*21)" # actual position [mdeg] -> rad
  vel_to_device: "rint(21*(vel*60/(2*pi)))" # rad/s -> rev/min
  vel_from_device: "(obj606C*2*pi)/(60*21)" # actual velocity [rev/min] -> rad/s
  eff_to_device: "rint(eff)" # just round to integer
  eff_from_device: "0" # unset 
  